/*
 * Decompiled with CFR 0.152.
 */
package com.le.sunriise.viewer;

import com.healthmarketscience.jackcess.ByteUtil;
import com.healthmarketscience.jackcess.Column;
import com.healthmarketscience.jackcess.Cursor;
import com.healthmarketscience.jackcess.DataType;
import com.healthmarketscience.jackcess.Table;
import com.le.sunriise.index.IndexLookup;
import com.le.sunriise.viewer.MnyViewer;
import java.awt.Component;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import javax.swing.table.AbstractTableModel;
import org.apache.log4j.Logger;

/*
 * This class specifies class file version 49.0 but uses Java 6 signatures.  Assumed Java 6.
 */
public class MnyTableModel
extends AbstractTableModel {
    private static final Logger log = Logger.getLogger(MnyTableModel.class);
    private final Table table;
    private int currentRow = 0;
    private Cursor cursor;
    private Map<String, Object> data = null;
    private boolean dbReadOnly = false;
    private IndexLookup indexLookup = new IndexLookup();

    public MnyTableModel(Table table) throws IOException {
        this.table = table;
        this.cursor = Cursor.createCursor(table);
        this.cursor.reset();
        this.cursor.moveToNextRow();
    }

    @Override
    public int getRowCount() {
        return this.table.getRowCount();
    }

    @Override
    public int getColumnCount() {
        return this.table.getColumnCount();
    }

    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        Object value = null;
        try {
            this.moveCursorToRow(rowIndex);
            value = this.data.get(this.getColumnName(columnIndex));
            if (value instanceof byte[]) {
                value = ByteUtil.toHexString((byte[])value);
            }
        }
        catch (IOException e) {
            log.error(e, e);
        }
        return value;
    }

    private void moveCursorToRow(int rowIndex) throws IOException {
        int delta = rowIndex - this.currentRow;
        this.currentRow = rowIndex;
        if (delta == 0) {
            if (this.data == null) {
                this.data = this.cursor.getCurrentRow();
            }
        } else if (delta < 0) {
            this.cursor.movePreviousRows(-delta);
            this.data = this.cursor.getCurrentRow();
        } else {
            this.cursor.moveNextRows(delta);
            this.data = this.cursor.getCurrentRow();
        }
    }

    @Override
    public String getColumnName(int column) {
        List<Column> cols = this.table.getColumns();
        return cols.get(column).getName();
    }

    @Override
    public boolean isCellEditable(int rowIndex, int columnIndex) {
        return !this.dbReadOnly;
    }

    @Override
    public Class<?> getColumnClass(int columnIndex) {
        if (this.table == null) {
            log.info("getColumnClass, t=" + this.table + ", " + columnIndex);
            return super.getColumnClass(columnIndex);
        }
        List<Column> cols = this.table.getColumns();
        Column column = cols.get(columnIndex);
        Class clz = MnyViewer.getColumnJavaClass(column);
        if (log.isDebugEnabled()) {
            log.debug("getColumnClass, " + columnIndex + ", " + clz);
        }
        return clz;
    }

    @Override
    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
        if (this.dbReadOnly) {
            return;
        }
        try {
            this.moveCursorToRow(rowIndex);
            this.cursor.setCurrentRowValue(this.table.getColumn(this.getColumnName(columnIndex)), aValue);
            this.data = this.cursor.getCurrentRow();
            this.fireTableCellUpdated(rowIndex, columnIndex);
        }
        catch (IOException e) {
            log.error(e, e);
        }
    }

    public boolean isDbReadOnly() {
        return this.dbReadOnly;
    }

    public void setDbReadOnly(boolean dbReadOnly) {
        this.dbReadOnly = dbReadOnly;
    }

    public void deleteRow(int rowIndex) {
        log.info("> deleteRow rowIndex=" + rowIndex);
        if (this.dbReadOnly) {
            return;
        }
        try {
            this.moveCursorToRow(rowIndex);
            this.cursor.deleteCurrentRow();
            this.currentRow = 0;
            this.data = null;
            this.cursor.reset();
            this.cursor.moveToNextRow();
            this.fireTableRowsDeleted(rowIndex, rowIndex);
        }
        catch (IOException e) {
            log.error(e, e);
        }
    }

    public void duplicateRow(int rowIndex, Component locationRealativeTo) {
        log.info("> duplicateRow rowIndex=" + rowIndex);
        if (this.dbReadOnly) {
            return;
        }
        try {
            this.moveCursorToRow(rowIndex);
            Table table = this.cursor.getTable();
            IndexLookup indexLooker = new IndexLookup();
            List<Column> columns = table.getColumns();
            Object[] dataArray = this.data.values().toArray();
            for (int i = 0; i < dataArray.length; ++i) {
                Column column = columns.get(i);
                if (!indexLooker.isPrimaryKeyColumn(column)) continue;
                Long max = indexLooker.getMax(column);
                max = max + 1L;
                dataArray[i] = max.toString();
            }
            int rowCount = table.getRowCount();
            table.addRow(dataArray);
            this.currentRow = 0;
            this.data = null;
            this.cursor.reset();
            this.cursor.moveToNextRow();
            this.fireTableRowsInserted(rowCount, rowCount);
        }
        catch (IOException e) {
            log.error(e, e);
        }
    }

    public boolean columnIsDateType(int i) {
        List<Column> columns = this.table.getColumns();
        if (columns == null) {
            return false;
        }
        if (i >= columns.size()) {
            return false;
        }
        Column column = columns.get(i);
        DataType dataType = column.getType();
        return dataType == DataType.SHORT_DATE_TIME;
    }

    public boolean isPrimaryKeyColumn(int i) {
        List<Column> columns = this.table.getColumns();
        if (columns == null) {
            return false;
        }
        if (i >= columns.size()) {
            return false;
        }
        Column column = columns.get(i);
        return this.indexLookup.isPrimaryKeyColumn(column);
    }

    public boolean isForeignKeyColumn(int i) {
        List<Column> columns = this.table.getColumns();
        if (columns == null) {
            return false;
        }
        if (i >= columns.size()) {
            return false;
        }
        Column column = columns.get(i);
        List<Column> referenced = null;
        try {
            referenced = this.indexLookup.getReferencedColumns(column);
        }
        catch (IOException e) {
            log.warn(e);
        }
        if (referenced == null) {
            return false;
        }
        return referenced.size() > 0;
    }
}

